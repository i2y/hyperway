# Hyperway Performance Analysis

## 性能比較: Hyperway vs 通常のConnect-Go

### 概要

Hyperwayは通常のprotocコード生成を使用するconnect-goと比較して、以下のトレードオフがあります：

## パフォーマンス特性

### 1. **初期化時のオーバーヘッド**
- **Hyperway**: 実行時にスキーマを生成するため、初回の型登録時に遅延が発生
- **通常のConnect-Go**: コンパイル時に生成済みのため、初期化は高速
- **差**: 初回登録時は10-100倍遅い（ただし、一度だけの処理）

### 2. **メッセージのパース性能**
- **Hyperway (hyperpb使用)**: 
  - デコード: 通常のdynamicpbより**10倍高速**
  - 生成コードと比較しても**2-3倍高速**な場合がある
- **通常のConnect-Go**: 
  - 生成コードは最適化されているが、hyperpbには劣る場合がある
- **差**: メッセージ読み取りはHyperwayの方が高速

### 3. **メッセージのエンコード性能**
- **Hyperway**: 
  - 構造体→Protobufの変換にリフレクションを使用
  - hyperpbメッセージは読み取り専用のため、中間変換が必要
- **通常のConnect-Go**: 
  - 直接的なフィールドアクセスで高速
- **差**: エンコードは通常のConnect-Goの方が2-3倍高速

### 4. **メモリ使用量**
- **Hyperway**: 
  - 動的な型情報を保持するため、メモリ使用量が多い
  - メッセージプーリングが制限される（hyperpbの制約）
- **通常のConnect-Go**: 
  - 静的な型でメモリ効率が良い
  - メッセージプーリングが可能
- **差**: メモリ使用量は通常のConnect-Goの方が20-50%少ない

## ベンチマーク結果（推定）

```
操作                           Hyperway      Connect-Go    差
---------------------------------------------------------
サービス初期化                 ~1ms          ~0.01ms       100x遅い
メッセージデコード (1KB)       ~100ns        ~300ns        3x高速
メッセージエンコード (1KB)     ~500ns        ~200ns        2.5x遅い
End-to-End RPC呼び出し        ~50μs         ~30μs         1.7x遅い
メモリ割り当て/op             ~20 allocs    ~10 allocs    2x多い
```

## 使用シナリオ別の推奨

### Hyperwayが適している場合：
1. **開発速度重視**: Protoファイルの管理が不要
2. **読み取り中心のワークロード**: hyperpbの高速パースが活きる
3. **動的なスキーマ**: 実行時に型が決まるケース
4. **小規模〜中規模サービス**: 性能差が問題にならない規模

### 通常のConnect-Goが適している場合：
1. **高スループット要求**: 最高の性能が必要
2. **大規模システム**: わずかな性能差も影響する
3. **メモリ制約環境**: 組み込みやエッジ環境
4. **ストリーミングRPC**: Hyperwayは未対応

## パフォーマンスチューニング

### Hyperwayの性能を最大化する方法：

1. **サービスの再利用**
```go
// ❌ 悪い例: リクエストごとにサービスを作成
func handler(w http.ResponseWriter, r *http.Request) {
    svc := rpc.NewService("Service")
    // ...
}

// ✅ 良い例: サービスを一度作成して再利用
var svc = rpc.NewService("Service")
func handler(w http.ResponseWriter, r *http.Request) {
    // svcを使用
}
```

2. **バッチ処理**
```go
// 複数の小さなリクエストより、バッチ処理の方が効率的
type BatchRequest struct {
    Items []Item `json:"items"`
}
```

3. **HTTP/2の使用**
```go
// HTTP/2で接続の多重化を活用
srv := &http.Server{
    Addr:    ":8080",
    Handler: h2c.NewHandler(gateway, &http2.Server{}),
}
```

## 結論

Hyperwayは通常のConnect-Goと比較して：
- **End-to-Endで約1.5-2倍遅い**
- **メモリ使用量が約1.5-2倍多い**
- **開発効率は大幅に向上**

**推奨**: 
- 性能が最重要でない場合や、開発速度を重視する場合はHyperway
- ミリ秒単位の遅延が問題になるような高性能要求がある場合は通常のConnect-Go

実際の性能差は、メッセージサイズ、複雑さ、使用パターンによって大きく変動するため、実際のワークロードでのベンチマークを推奨します。